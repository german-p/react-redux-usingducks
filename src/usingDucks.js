const { success, failure } = require('react-redux-async-action');

/**
 * Defines a logical grouping of actions with their reducer logic in one place.
 * You can have many usingDucks instances in your app and you will have to do the combineReducers in your
 * redux config for each reducer that each instance generates.
 * @param {any} initialState The initial state to use for the reducer generated by this duck
 * @param {string} namespace The name of the logical grouping of the actions of this duck.
 * This string will be prefixed to every action exported by this duck for easier tracking in redux dev tools.
 * @returns {object} The duck object.
 */
function usingDucks(initialState = {}, namespace) {
  const config = {};
  const conditionalReducers = [];
  let duckInitialState = initialState;
  if (namespace && typeof namespace !== 'string') throw new Error('The namespace must be a string');

  const isFunction = obj => !!(obj && obj.constructor && obj.call && obj.apply);
  function composeTrackWith(reducer, type, trackWith, isRunning) {
    if (!trackWith) return reducer;
    const trackWithIsAFunction = isFunction(trackWith);
    if (!trackWithIsAFunction) duckInitialState = { ...initialState, [trackWith]: false };
    else duckInitialState = trackWith(initialState, undefined, false);

    return (state, payload, error) => {
      let nextState = state;

      if (trackWithIsAFunction) {
        nextState = trackWith(state, payload, isRunning);
        if (!nextState) throw new Error(`trackWith function of the ${type} action should return a state object`);
      } else {
        nextState = ({ ...state, [trackWith]: isRunning });
      }
      if (reducer) {
        return reducer(nextState, payload, error);
      }
      return nextState;
    };
  }

  /**
  * Registers a reducer to execute when a specified action is dispatched.
  * Expected function (state, payload, error) => state;
  * @param {string|function} actionType The action type constant or a function (action)=> bool that determines if the reducer function should
  * be used for the given action
  * @param {function} reducerFn The reducer function that will handle this action (state, payload, error) => state
  * @return {undefined}
  */
  function reduce(actionType, reducerFn) {
    const ns = namespace ? ` [${namespace}]` : '';
    if (typeof actionType === 'string') {
      if (config[actionType]) { throw new Error(`${actionType} is already being reduced by this${ns} duck. Unify your reducer code in the action definition reducer`); }
      if (!reducerFn) { throw new Error(`The reducer function argument for ${actionType} reduce is required`); }
      config[actionType] = reducerFn;
    } else if (typeof actionType === 'function') {
      conditionalReducers.push({ actionCondition: actionType, reducer: reducerFn });
    } else {
      throw new Error('actionType parameter must be a string or a function');
    }
  }
  /**
   * Creates an action creator and register the reducers that will handle the action.
   * @param {object} definition The object with the action definition parameters
   * @param {string} definition.type (required) The action type constant
   * @param {string|function} definition.trackWith the name of the store property that will track the running state of this async action
   * or a function that will update the store with it
   * @param {function} definition.reducer The reducer function that will be executed when this action is dispatched.
   * @param {function} definition.successReducer The reducer function when this is an async action and the call succeeds (does not fail)
   * (state, payload)=> state
   * @param {function} definition.failureReducer The reducer function when this is an asyuc action and the call throws an exception.
   * (state, payload, error)=> state
   * @returns {function} The action creator
  */
  function makeActionCreator(definition) {
    if (!definition) throw new Error('The action definition parameter is required');
    if (!definition.type) throw new Error('The action definition must have a value for type');
    if (typeof definition.type !== 'string') throw new Error('The action definition type must be a string');
    const {
      type, reducer, successReducer, failureReducer, trackWith,
    } = definition;

    const actionType = namespace ? `[${namespace}] ${type}` : type;
    const reducerFn = composeTrackWith(reducer, actionType, trackWith, true);
    if (reducerFn) reduce(actionType, reducerFn);
    const successReducerFn = composeTrackWith(successReducer, actionType, trackWith, false);
    if (successReducerFn) reduce(success(actionType), successReducerFn);
    const failureReducerFn = composeTrackWith(failureReducer, actionType, trackWith, false);
    if (failureReducerFn) reduce(failure(actionType), failureReducerFn);

    return payload => ({ type: actionType, payload });
  }

  /**
   * Creates the main reducer function for the actions of the duck
   * @param {object} childReducers The object containing the reducer functions to be combined with this reducer
   * @returns {function} the reducer function (state, action)=> state;
   */
  function createReducer(childReducers) {
    if (childReducers) {
      Object.keys(childReducers).forEach((key) => {
        if (typeof childReducers[key] !== 'function') throw new Error(`childReducers.${key} is not a function`);
      });
    }
    return (state = duckInitialState, action) => {
      let newState = state;
      if (action && action.type) {
        // if any action matches
        if (config[action.type]) {
          newState = config[action.type](state, action.payload, action.error);
          if (!newState) throw new Error(`The reducer of the ${action.type} action does not return a state object`);
        }
        // child reducers
        if (childReducers) {
          const childState = Object.keys(childReducers).reduce(
            (nextState, key) => {
              nextState[key] = childReducers[key](newState[key], action);
              return nextState;
            },
            {},
          );
          newState = { ...newState, ...childState };
        }

        return conditionalReducers.reduce((currState, conditional) => {
          if (conditional.actionCondition(action) === true) {
            return conditional.reducer(currState);
          }
          return currState;
        }, newState);
      }
      return state;
    };
  }

  return { makeActionCreator, createReducer, reduce };
}

module.exports = usingDucks;
